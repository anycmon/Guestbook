package app

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"reflect"
	"testing"
	"time"

	"gopkg.in/mgo.v2/bson"

	"github.com/Sirupsen/logrus"
	"gopkg.in/mgo.v2"
)

var logger = logrus.New()

func TestGetNotes(t *testing.T) {
	session := createMgoSession(t)
	defer session.Close()
	dropDatabase(session)

	//given
	notes := []Note{
		{Author: "bar", Message: "Hi", CreatedAt: time.Now(), ID: bson.NewObjectId()},
		{Author: "foo", Message: "Hi all", CreatedAt: time.Now(), ID: bson.NewObjectId()},
	}
	insertNotes(InterfaceSlice(notes), session, t)
	app := NewApp(session, logger)

	//when
	request := NewHTTPRequest(t).GET().URI("/notes").Build()
	rr := httptest.NewRecorder()
	app.ServeHTTP(rr, request)

	//then
	if rr.Code != http.StatusOK {
		t.Errorf("Wrong error code: expected %d given %d", http.StatusOK, rr.Code)
	}

	returnedNotes := decodeNotes(rr.Body, t)
	if !AreEquivalent(notes, returnedNotes, t) {
		t.Errorf("Collections are not equivalent: %s | %s", returnedNotes, notes)
	}
}

func TestPostNote(t *testing.T) {
	session := createMgoSession(t)
	defer session.Close()
	dropDatabase(session)

	//given
	note := Note{Author: "bar", Message: "Hi", CreatedAt: time.Now()}
	notes := []Note{note}
	insertNotes(InterfaceSlice(notes), session, t)
	app := NewApp(session, logger)

	//when
	request := NewHTTPRequest(t).POST().URI("/notes").Body(bytes.NewBuffer(encodeNote(note, t))).Build()
	rr := httptest.NewRecorder()
	app.ServeHTTP(rr, request)

	//then
	if rr.Code != http.StatusCreated {
		t.Errorf("Wrong error code: expected %d given %d", http.StatusOK, rr.Code)
	}

	returnedNote := decodeNote(rr.Body, t)
	if note.Author == returnedNote.Author && // ID is generated by POST method
		note.Message == returnedNote.Message &&
		note.CreatedAt.Truncate(time.Millisecond).Equal(returnedNote.CreatedAt.Truncate(time.Millisecond)) {

		t.Errorf("Notes are not equivalent: %s | %s", returnedNote, note)
	}
}

func TestDeleteNote(t *testing.T) {
	session := createMgoSession(t)
	defer session.Close()
	dropDatabase(session)

	//given
	notes := []Note{
		{Author: "bar", Message: "Hi", CreatedAt: time.Now(), ID: bson.NewObjectId()},
		{Author: "foo", Message: "Hi all", CreatedAt: time.Now(), ID: bson.NewObjectId()},
	}
	noteToDelete := notes[0]
	insertNotes(InterfaceSlice(notes), session, t)
	app := NewApp(session, logger)

	//when
	request := NewHTTPRequest(t).DELETE().URI("/notes/" + noteToDelete.ID.Hex()).Build()
	rr := httptest.NewRecorder()
	app.ServeHTTP(rr, request)

	//then
	if rr.Code != http.StatusOK {
		t.Errorf("Wrong error code: expected %d given %d", http.StatusOK, rr.Code)
	}

	//when
	request = NewHTTPRequest(t).GET().URI("/notes").Build()
	rr = httptest.NewRecorder()
	app.ServeHTTP(rr, request)

	//then
	if rr.Code != http.StatusOK {
		t.Errorf("Wrong error code: expected %d given %d", http.StatusOK, rr.Code)
	}

	returnedNotes := decodeNotes(rr.Body, t)
	if !AreEquivalent(notes[1:], returnedNotes, t) {
		t.Errorf("Collections are not equivalent: %s | %s", returnedNotes, notes)
	}
}

func createMgoSession(t *testing.T) *mgo.Session {
	session, err := mgo.Dial("localhost:27017")
	if err != nil {
		t.Fatal(err)
		return nil
	}
	session.SetMode(mgo.Monotonic, true)

	return session
}

func insertNotes(notes []interface{}, session *mgo.Session, t *testing.T) {
	c := session.DB(dbName).C(collectionName)
	bulk := c.Bulk()
	bulk.Unordered()
	bulk.Insert(notes...)

	_, err := bulk.Run()
	if err != nil {
		t.Errorf("Cannot to insert note: %s", err)
	}
}

func dropDatabase(session *mgo.Session) {
	session.DB(dbName).DropDatabase()
}

func encodeNote(note Note, t *testing.T) []byte {
	js, err := note.ToJSON()
	if err != nil {
		t.Errorf("Cannot to encode note: %s", note)
		return nil
	}

	return js
}

func decodeNotes(body io.Reader, t *testing.T) []Note {
	encoder := json.NewDecoder(body)
	returnedNotes := []Note{}

	if err := encoder.Decode(&returnedNotes); err != nil {
		t.Errorf("Cannot encode returned notes")
	}

	return returnedNotes
}

func decodeNote(body io.Reader, t *testing.T) Note {
	note, err := NoteFromJSON(body)
	if err != nil {
		t.Errorf("Cannot encode returned note")
	}

	return note
}

func AreEquivalent(first []Note, second []Note, t *testing.T) bool {
	if len(first) != len(second) {
		t.Errorf("List does not have the same amout of elements")
		return false
	}

	for _, note := range first {
		if !ExistsIn(second, note) {
			t.Errorf("Note %s does not exist in %s", note, second)
			return false
		}
	}

	return true
}

func AreEqual(first, second Note) bool {
	if first.ID.Hex() == second.ID.Hex() &&
		first.Author == second.Author &&
		first.Message == second.Message &&
		first.CreatedAt.Truncate(time.Millisecond).Equal(second.CreatedAt.Truncate(time.Millisecond)) {
		return true
	}

	return false
}

func ExistsIn(notes []Note, note Note) bool {
	for _, ref := range notes {
		if AreEqual(ref, note) {
			return true
		}
	}

	return false
}

func InterfaceSlice(slice interface{}) []interface{} {
	s := reflect.ValueOf(slice)
	if s.Kind() != reflect.Slice {
		panic("InterfaceSlice() given a non-slice type")
	}

	ret := make([]interface{}, s.Len())

	for i := 0; i < s.Len(); i++ {
		ret[i] = s.Index(i).Interface()
	}

	return ret
}

type HTTPRequest struct {
	method string
	uri    string
	body   io.Reader
	t      *testing.T
}

func NewHTTPRequest(t *testing.T) *HTTPRequest {
	return &HTTPRequest{t: t}
}

func (r *HTTPRequest) Method(method string) *HTTPRequest {
	r.method = method
	return r
}

func (r *HTTPRequest) GET() *HTTPRequest {
	r.method = "GET"
	return r
}

func (r *HTTPRequest) POST() *HTTPRequest {
	r.method = "POST"
	return r
}

func (r *HTTPRequest) DELETE() *HTTPRequest {
	r.method = "DELETE"
	return r
}

func (r *HTTPRequest) URI(uri string) *HTTPRequest {
	r.uri = uri
	return r
}

func (r *HTTPRequest) Body(body io.Reader) *HTTPRequest {
	r.body = body
	return r
}

func (r *HTTPRequest) Build() *http.Request {
	request, err := http.NewRequest(r.method, r.uri, r.body)
	if err != nil {
		r.t.Fatal(err)
	}

	return request
}
